基本模板术语
##################

类模板还是模板类
=====================

在 C++ 中，结构体、类、联合体都被称为类类型。而单词 ”类“ 一般表示由关键字 ``class`` 或者关键字 ``struct`` 定义的型别。

关于本身是模板的类称作什么存在着一些混乱：

- 术语 ``class template`` 说明类是一个模板。也就是说，它是一组类的参数化描述

- 另一方面来说，术语 ``template class`` 被用作：
    
    * 作为 ``class template`` 的同义词

    * 引用从模板生成的类

    * 引用名称是 ``template-id`` （模板名称后面跟着模板实参，Foo<int, char>） 的类


由于不精确性，应该避免使用 ``template class`` 。

类似地，我们使用 ``function template``， ``member tempalte``， ``member function tempalte``和 ``variable tempalte``，
避免使用 ``template function``， ``tempalte member``， ``tempalte member function``和 ``tempalte variable``。

替换，实例化和特化
=====================

当处理使用模板的源代码时，C++编译器必须在不同的时间使用模板实参替换模板参数。有时，这个替换只是尝试性的：编译器可能需要检查替换是否是有效的。      

从一个模板通过使用具体的模板实参替换模板参数创建一个普通的类，类型别名，函数，成员方法的 **定义** 的过程，被称作模板实例化。

令人吃惊的是，目前还没有标准或者普遍同意的术语来表示通过模板参数替换创建一个声明的过程。目前有些团队使用 **部分实例化** 或者 **实例化声明** 来
表示这个过程，但是它们一点也不通用。可能一个更直观的术语是 **不完整的实例化** （就类模板而言，此时会产生一个不完整的类）。

从实例化或者不完整的实例化产生的实体（比如，类，函数，成员方法或者变量），通常被叫做 **特化** 。

而然，在C++中，实例化过程并不是产生特化的唯一方式。可选的机制允许程序员显示指定一个声明被绑定到一个特殊的模板参数替换。通过
使用 ``template<>`` 前缀引入。严格来说，这被称作 **显示特化** 。

如果特化之后还有模板参数则被称作 **偏特化** 。

.. code-block:: c++

    // 主模板
    template<typename T1, typename T2>
    class MyClass {
        ....
    };

    // 显示特化
    template<>
    class MyClass<std::string, float> {
        ....
    };

    // 偏特化 
    template<T>
    class MyClass<T, T> {
        ...
    };

    // 偏特化 
    template<T>
    class MyClass<bool, T> {
        ...
    };

当讨论（显示或者部分）特化时，通用模板也被称作 **主模板** 。

声明和定义
==============

**声明** 是一个C++构造，它引入或者重新引入一个名称到C++的作用域内。声明总是包括了对名称的部分分类，但是还不需要名称的细节来
使得它成为一个有效的声明。（也就是说，声明能够告诉我们该名称的一个大致分类，比如它是类名，函数名，变量名，形参名等，但是它不用
告诉我们类具体有哪些成员变量、成员方法等，函数由哪些语句构成，变量需要分配多大空间等）。

.. code-block:: c++

    class C; // 声明 C 是一个类
    void f(int p); // 声明 f() 为一个函数并且声明 p 为一个命名参数
    extern int v; // 声明 v 是一个变量

注意宏定义和 goto 标签即使拥有”名称“，但是不被认为是C++中的声明。

当结构的细节已经知道，或者对于变量来说，存储空间已经被分配，此时声明就变成了 **定义** 。

.. code-block:: c++

    class C {}; // 类 C 的定义

    // 函数 f() 的定义
    void f(int p) {
        std::cout << p << '\n'; 
    }

    extern int v = 1; // 初始化使得 v 变成定义

    int w; // 不带 extern 的全局变量也是定义

完整类型和不完整类型
------------------------

型别可以是完整的或者不完整的，它与声明与定义的差别紧密相关。一些语言构造需要完整类型，然而其它的对不完整类型也是有效的。

不完整类型是以下几种之一：

- 类类型仅声明而未定义

- 数组类型未指定边界

- 数组类型的元素类型是不完整类型

- void

- 潜在类型或者枚举值未定义的枚举类型

- 上述所有类型添加 const 和 volatile 修饰词


所有其他的类型都是完整类型。

.. code-block:: c++

    class C; // C 是不完整类型
    C const* cp; // cp 是一个指向不完整类型的指针
    extern C elems[10]; // elems 是不完整类型
    extern int arr[]; // arr 是不完整类型

    ...
    class C {}; // C 现在是完整类型
    int arr[10]; // arr 现在是完整类型

一处定义规则
=====================

C++语言定义对各种实体的重新声明提出了一些约束。这些约束整体被称作 **one-defintion rule** 或者 **ODR** 。到目前为止，记住以下 ODR 要素
已经足够：

- 普通（非模板）非内联的函数和成员方法，以及（非内联）的全局变量和静态数据成员在整个程序中应该只被定义一次

- 类类型（包括结构体和联合体），模板（包括偏特化但不包括全特化），以及内联函数和每个编译单元至多被定义一次的变量（静态变量），所有的定义都应该等同

可链接实体指以下实体：函数或者成员方法，全局变量或者静态数据成员，包括由模板生成的上述实体，对链接器可见。

模板实参和模板参数
=======================

.. code-block:: c++

    template<typename T, int N>
    class ArrayInClass {
    public:
        T array[N];
    };

    class DoubleArrayInClass {
    public:
        double array[10];
    };

如果分别使用 double 和 10 替换参数 和 N ， DoubleArrayInClass 本质上和 ArrayInClass 等价。在C++中，替换的名称表示为 ``ArrayInClass<double, 10>`` 。

不管这些实参本身是否依赖于模板参数，模板名称，后面跟着在尖括号中的实参，合起来被成名 **template-id** 。

区分模板参数和模板实参是极其重要的。简而言之，你可以认为”参数被实参初始化“，或者更精确点：

- 模板参数是指在模板声明和模板定义中，那些被陈列在关键字 template 之后的名称（比如上述例子的 T 和 N）

- 模板实参是指为模板参数进行替换的元素（比如 double 和 10）。与模板参数不同的是，模板实参不仅仅是 ”名称“ 。 

当使用 template-id 表示时，通过模板实参替换模板参数的过程是明确的，但是还存在各种隐晦的替换情况（比如，如果模板参数被默认实参替换）。

一个基本原则就是，任何模板实参必须是一个编译时能被确定数量或者值。因为模板参数都是编译时实体，因此它们可能被用作有效的模板实参。

.. code-block:: c++

    template<typename T>
    class Dozen {
    public:
        ArrayInClass<T, 12> contents; // T 既是 Dozen 的模板参数，也是 ArrayInClass<T, 12> 的模板实参
    };


